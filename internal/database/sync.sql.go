// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync.sql

package database

import (
	"context"
	"database/sql"
)

const createSyncMeta = `-- name: CreateSyncMeta :exec
INSERT OR IGNORE INTO user_collections (user_id, usn, last_sync) 
VALUES (?, 0, NULL)
`

func (q *Queries) CreateSyncMeta(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, createSyncMeta, userID)
	return err
}

const deleteSpecificCard = `-- name: DeleteSpecificCard :exec
DELETE FROM user_cards WHERE id = ? AND user_id = ?
`

type DeleteSpecificCardParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteSpecificCard(ctx context.Context, arg DeleteSpecificCardParams) error {
	_, err := q.db.ExecContext(ctx, deleteSpecificCard, arg.ID, arg.UserID)
	return err
}

const deleteSpecificDeck = `-- name: DeleteSpecificDeck :exec
DELETE FROM user_decks WHERE id = ? AND user_id = ?
`

type DeleteSpecificDeckParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteSpecificDeck(ctx context.Context, arg DeleteSpecificDeckParams) error {
	_, err := q.db.ExecContext(ctx, deleteSpecificDeck, arg.ID, arg.UserID)
	return err
}

const deleteSpecificNote = `-- name: DeleteSpecificNote :exec
DELETE FROM user_notes WHERE id = ? AND user_id = ?
`

type DeleteSpecificNoteParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteSpecificNote(ctx context.Context, arg DeleteSpecificNoteParams) error {
	_, err := q.db.ExecContext(ctx, deleteSpecificNote, arg.ID, arg.UserID)
	return err
}

const deleteUserCards = `-- name: DeleteUserCards :exec
DELETE FROM user_cards WHERE user_id = ?
`

func (q *Queries) DeleteUserCards(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserCards, userID)
	return err
}

const deleteUserDecks = `-- name: DeleteUserDecks :exec
DELETE FROM user_decks WHERE user_id = ?
`

func (q *Queries) DeleteUserDecks(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserDecks, userID)
	return err
}

const deleteUserGraves = `-- name: DeleteUserGraves :exec
DELETE FROM user_graves WHERE user_id = ?
`

func (q *Queries) DeleteUserGraves(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserGraves, userID)
	return err
}

const deleteUserMedia = `-- name: DeleteUserMedia :exec
DELETE FROM user_media WHERE user_id = ?
`

func (q *Queries) DeleteUserMedia(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserMedia, userID)
	return err
}

const deleteUserNotes = `-- name: DeleteUserNotes :exec
DELETE FROM user_notes WHERE user_id = ?
`

func (q *Queries) DeleteUserNotes(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserNotes, userID)
	return err
}

const getCardsSince = `-- name: GetCardsSince :many
SELECT id, note_id, deck_id, ordinal, modified_at, usn, state, queue, due, 
    interval, ease_factor, reps, lapses, left_count, original_due, original_deck_id, flags, data
FROM user_cards
WHERE user_id = ? AND usn > ?
ORDER BY usn
`

type GetCardsSinceParams struct {
	UserID int64 `json:"user_id"`
	Usn    int64 `json:"usn"`
}

type GetCardsSinceRow struct {
	ID             int64  `json:"id"`
	NoteID         int64  `json:"note_id"`
	DeckID         int64  `json:"deck_id"`
	Ordinal        int64  `json:"ordinal"`
	ModifiedAt     int64  `json:"modified_at"`
	Usn            int64  `json:"usn"`
	State          int64  `json:"state"`
	Queue          int64  `json:"queue"`
	Due            int64  `json:"due"`
	Interval       int64  `json:"interval"`
	EaseFactor     int64  `json:"ease_factor"`
	Reps           int64  `json:"reps"`
	Lapses         int64  `json:"lapses"`
	LeftCount      int64  `json:"left_count"`
	OriginalDue    int64  `json:"original_due"`
	OriginalDeckID int64  `json:"original_deck_id"`
	Flags          int64   `json:"flags"`
	Data           string  `json:"data"`
	Stability      float64 `json:"stability"`
	Difficulty     float64 `json:"difficulty"`
}

func (q *Queries) GetCardsSince(ctx context.Context, arg GetCardsSinceParams) ([]GetCardsSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getCardsSince, arg.UserID, arg.Usn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCardsSinceRow
	for rows.Next() {
		var i GetCardsSinceRow
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.DeckID,
			&i.Ordinal,
			&i.ModifiedAt,
			&i.Usn,
			&i.State,
			&i.Queue,
			&i.Due,
			&i.Interval,
			&i.EaseFactor,
			&i.Reps,
			&i.Lapses,
			&i.LeftCount,
			&i.OriginalDue,
			&i.OriginalDeckID,
			&i.Flags,
			&i.Data,
			&i.Stability,
			&i.Difficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDecksSince = `-- name: GetDecksSince :many
SELECT id, name, description, config_id, created_at, modified_at, usn
FROM user_decks
WHERE user_id = ? AND usn > ?
ORDER BY usn
`

type GetDecksSinceParams struct {
	UserID int64 `json:"user_id"`
	Usn    int64 `json:"usn"`
}

type GetDecksSinceRow struct {
	ID          int64          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	ConfigID    sql.NullInt64  `json:"config_id"`
	CreatedAt   int64          `json:"created_at"`
	ModifiedAt  int64          `json:"modified_at"`
	Usn         int64          `json:"usn"`
}

func (q *Queries) GetDecksSince(ctx context.Context, arg GetDecksSinceParams) ([]GetDecksSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getDecksSince, arg.UserID, arg.Usn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDecksSinceRow
	for rows.Next() {
		var i GetDecksSinceRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ConfigID,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.Usn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGravesSince = `-- name: GetGravesSince :many
SELECT oid, type FROM user_graves
WHERE user_id = ? AND usn > ?
ORDER BY usn
`

type GetGravesSinceParams struct {
	UserID int64 `json:"user_id"`
	Usn    int64 `json:"usn"`
}

type GetGravesSinceRow struct {
	Oid  int64 `json:"oid"`
	Type int64 `json:"type"`
}

func (q *Queries) GetGravesSince(ctx context.Context, arg GetGravesSinceParams) ([]GetGravesSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getGravesSince, arg.UserID, arg.Usn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGravesSinceRow
	for rows.Next() {
		var i GetGravesSinceRow
		if err := rows.Scan(&i.Oid, &i.Type); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotesSince = `-- name: GetNotesSince :many
SELECT id, guid, mid, mod, usn, tags, flds, sfld, csum, flags, data
FROM user_notes
WHERE user_id = ? AND usn > ?
ORDER BY usn
`

type GetNotesSinceParams struct {
	UserID int64 `json:"user_id"`
	Usn    int64 `json:"usn"`
}

type GetNotesSinceRow struct {
	ID    int64  `json:"id"`
	Guid  string `json:"guid"`
	Mid   int64  `json:"mid"`
	Mod   int64  `json:"mod"`
	Usn   int64  `json:"usn"`
	Tags  string `json:"tags"`
	Flds  string `json:"flds"`
	Sfld  string `json:"sfld"`
	Csum  int64  `json:"csum"`
	Flags int64  `json:"flags"`
	Data  string `json:"data"`
}

func (q *Queries) GetNotesSince(ctx context.Context, arg GetNotesSinceParams) ([]GetNotesSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getNotesSince, arg.UserID, arg.Usn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotesSinceRow
	for rows.Next() {
		var i GetNotesSinceRow
		if err := rows.Scan(
			&i.ID,
			&i.Guid,
			&i.Mid,
			&i.Mod,
			&i.Usn,
			&i.Tags,
			&i.Flds,
			&i.Sfld,
			&i.Csum,
			&i.Flags,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncMeta = `-- name: GetSyncMeta :one
SELECT usn, last_sync FROM user_collections 
WHERE user_id = ? LIMIT 1
`

type GetSyncMetaRow struct {
	Usn      int64        `json:"usn"`
	LastSync sql.NullTime `json:"last_sync"`
}

func (q *Queries) GetSyncMeta(ctx context.Context, userID int64) (GetSyncMetaRow, error) {
	row := q.db.QueryRowContext(ctx, getSyncMeta, userID)
	var i GetSyncMetaRow
	err := row.Scan(&i.Usn, &i.LastSync)
	return i, err
}

const getUSN = `-- name: GetUSN :one
SELECT usn FROM user_collections WHERE user_id = ?
`

func (q *Queries) GetUSN(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUSN, userID)
	var usn int64
	err := row.Scan(&usn)
	return usn, err
}

const recordGrave = `-- name: RecordGrave :exec
INSERT INTO user_graves (user_id, usn, oid, type) 
VALUES (?, ?, ?, ?)
`

type RecordGraveParams struct {
	UserID int64 `json:"user_id"`
	Usn    int64 `json:"usn"`
	Oid    int64 `json:"oid"`
	Type   int64 `json:"type"`
}

func (q *Queries) RecordGrave(ctx context.Context, arg RecordGraveParams) error {
	_, err := q.db.ExecContext(ctx, recordGrave,
		arg.UserID,
		arg.Usn,
		arg.Oid,
		arg.Type,
	)
	return err
}

const resetUserUSN = `-- name: ResetUserUSN :exec
UPDATE user_collections SET usn = 0, last_sync = NULL WHERE user_id = ?
`

func (q *Queries) ResetUserUSN(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, resetUserUSN, userID)
	return err
}

const updateUSN = `-- name: UpdateUSN :one
UPDATE user_collections 
SET usn = usn + 1, last_sync = CURRENT_TIMESTAMP 
WHERE user_id = ? 
RETURNING usn
`

func (q *Queries) UpdateUSN(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateUSN, userID)
	var usn int64
	err := row.Scan(&usn)
	return usn, err
}

const upsertCard = `-- name: UpsertCard :exec
INSERT INTO user_cards (id, user_id, note_id, deck_id, ordinal, modified_at, usn, 
    state, queue, due, interval, ease_factor, reps, lapses, left_count,
    original_due, original_deck_id, flags, data)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    note_id = excluded.note_id,
    deck_id = excluded.deck_id,
    ordinal = excluded.ordinal,
    modified_at = excluded.modified_at,
    usn = excluded.usn,
    state = excluded.state,
    queue = excluded.queue,
    due = excluded.due,
    interval = excluded.interval,
    ease_factor = excluded.ease_factor,
    reps = excluded.reps,
    lapses = excluded.lapses,
    left_count = excluded.left_count,
    original_due = excluded.original_due,
    original_deck_id = excluded.original_deck_id,
    flags = excluded.flags,
    data = excluded.data
`

type UpsertCardParams struct {
	ID             int64  `json:"id"`
	UserID         int64  `json:"user_id"`
	NoteID         int64  `json:"note_id"`
	DeckID         int64  `json:"deck_id"`
	Ordinal        int64  `json:"ordinal"`
	ModifiedAt     int64  `json:"modified_at"`
	Usn            int64  `json:"usn"`
	State          int64  `json:"state"`
	Queue          int64  `json:"queue"`
	Due            int64  `json:"due"`
	Interval       int64  `json:"interval"`
	EaseFactor     int64  `json:"ease_factor"`
	Reps           int64  `json:"reps"`
	Lapses         int64  `json:"lapses"`
	LeftCount      int64  `json:"left_count"`
	OriginalDue    int64  `json:"original_due"`
	OriginalDeckID int64  `json:"original_deck_id"`
	Flags          int64   `json:"flags"`
	Data           string  `json:"data"`
	Stability      float64 `json:"stability"`
	Difficulty     float64 `json:"difficulty"`
}

func (q *Queries) UpsertCard(ctx context.Context, arg UpsertCardParams) error {
	_, err := q.db.ExecContext(ctx, upsertCard,
		arg.ID,
		arg.UserID,
		arg.NoteID,
		arg.DeckID,
		arg.Ordinal,
		arg.ModifiedAt,
		arg.Usn,
		arg.State,
		arg.Queue,
		arg.Due,
		arg.Interval,
		arg.EaseFactor,
		arg.Reps,
		arg.Lapses,
		arg.LeftCount,
		arg.OriginalDue,
		arg.OriginalDeckID,
		arg.Flags,
		arg.Data,
		arg.Stability,
		arg.Difficulty,
	)
	return err
}

const upsertDeck = `-- name: UpsertDeck :exec
INSERT INTO user_decks (id, user_id, name, description, config_id, created_at, modified_at, usn)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    name = excluded.name,
    description = excluded.description,
    config_id = excluded.config_id,
    modified_at = excluded.modified_at,
    usn = excluded.usn
`

type UpsertDeckParams struct {
	ID          int64          `json:"id"`
	UserID      int64          `json:"user_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	ConfigID    sql.NullInt64  `json:"config_id"`
	CreatedAt   int64          `json:"created_at"`
	ModifiedAt  int64          `json:"modified_at"`
	Usn         int64          `json:"usn"`
}

func (q *Queries) UpsertDeck(ctx context.Context, arg UpsertDeckParams) error {
	_, err := q.db.ExecContext(ctx, upsertDeck,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.ConfigID,
		arg.CreatedAt,
		arg.ModifiedAt,
		arg.Usn,
	)
	return err
}

const upsertNote = `-- name: UpsertNote :exec
INSERT INTO user_notes (id, user_id, guid, mid, mod, usn, tags, flds, sfld, csum, flags, data)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    guid = excluded.guid,
    mid = excluded.mid,
    mod = excluded.mod,
    usn = excluded.usn,
    tags = excluded.tags,
    flds = excluded.flds,
    sfld = excluded.sfld,
    csum = excluded.csum,
    flags = excluded.flags,
    data = excluded.data
`

type UpsertNoteParams struct {
	ID     int64  `json:"id"`
	UserID int64  `json:"user_id"`
	Guid   string `json:"guid"`
	Mid    int64  `json:"mid"`
	Mod    int64  `json:"mod"`
	Usn    int64  `json:"usn"`
	Tags   string `json:"tags"`
	Flds   string `json:"flds"`
	Sfld   string `json:"sfld"`
	Csum   int64  `json:"csum"`
	Flags  int64  `json:"flags"`
	Data   string `json:"data"`
}

func (q *Queries) UpsertNote(ctx context.Context, arg UpsertNoteParams) error {
	_, err := q.db.ExecContext(ctx, upsertNote,
		arg.ID,
		arg.UserID,
		arg.Guid,
		arg.Mid,
		arg.Mod,
		arg.Usn,
		arg.Tags,
		arg.Flds,
		arg.Sfld,
		arg.Csum,
		arg.Flags,
		arg.Data,
	)
	return err
}
